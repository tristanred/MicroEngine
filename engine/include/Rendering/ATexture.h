#pragma once

class ARenderer;

#include <libtech/arraylist.h>

#include <cstdint>

#include "core.h"
#include "libtech/geometry.h"

/**
 * \brief Abstract texture class.
 *
 * Instances of this class MUST be generated by the ARenderer to make sure
 * that they are properly built using the concrete rendering library.
 */
class ENGINE_CLASS ATexture
{
public:
    explicit ATexture(ARenderer* renderer);
    virtual ~ATexture();

    // Texture modification methods, calling any of them will probably reset the
    // texture

    /**
     * \brief Set the texture to be filled with a specific color.
     *
     * This will create a new pixel buffer and fill it with color. If you need
     * to fill the current texture, use the ATexture::FillColor instead.
     *
     * \param size - Size of the texture, the texture will be resized too this
     * size.
     * \param color - Color to use when filling.
     */
    virtual void SetSolidColor(FSize size, uint32_t color) = 0;

    /**
     * \brief Load the texture data from a file.
     *
     * Must be in a format known by the concrete rendering library.
     *
     * \param filepath - Path of the file to load.
     */
    virtual void LoadFromFile(const char* filepath) = 0;

    /**
     * \brief Get the size of this texture.
     *
     * \return FSize - Size of this texture in pixels.
     */
    virtual FSize GetSize();

    /**
     * \brief Set the size of the texture.
     *
     * This resizes the current texture so it will stretch/shrink the pixel
     * data.
     *
     * \param size - New size to use.
     */
    virtual void SetSize(FSize size);

    /**
     * \brief Fill the current texture with color.
     *
     * This keeps the texture at the same size but just draws over the current
     * pixels with a new color.
     *
     * \param color - Color to use.
     */
    virtual void FillColor(uint32_t color) = 0;

    /**
     * \brief Draw the outline of a rectangle.
     *
     * The strokes of the rectangle will start at the specified rec and grow
     * on the inside by the specified size.
     *
     * \param rect - Rectangle to stroke.
     * \param size - Size of the rectangle strokes;
     * \param color - Color to use when drawing. Format is RGBA.
     */
    virtual void StrokeRect(FRectangle rect, uint32_t size, uint32_t color) = 0;

    /**
     * \brief Fill a rectangle on the texture with the specified color.
     *
     * \param rect - Rectangle to fill.
     * \param color - Color to use when drawing. Format is RGBA
     */
    virtual void FillRect(FRectangle rect, uint32_t color) = 0;

    /**
     * \brief Draw a line on the texture.
     *
     * \param pos1 - Position 1
     * \param pos2 - Position 2
     * \param color - Color for the line
     * \param size - Size of the line (unused for now)
     */
    virtual void DrawLine(FPosition pos1,
                          FPosition pos2,
                          uint32_t color,
                          uint32_t size) = 0;

    /**
     * \brief Free all memory allocated by this texture.
     *
     * This can help when the system is under memory pressure. The texture can
     * no longer be drawn after being freed but the game can reload it from
     * it's original location without re-applying it to all objects.
     */
    virtual void FreeTextureMemory() = 0;

    /**
     * \brief Reload the texture from it's original location.
     *
     * Not super well implemented right now as it just reloads the file, not
     * helpful if managing a texture from a package file or some ephemeral data
     * store.
     */
    virtual void ReloadTexture() = 0;

    /**
     * \brief Get the path of the texture.
     *
     * This returns where the texture was loaded on the filesystem, might not be
     * so useful if the texture was created from an Asset instance.
     */
    virtual const char* GetTexturePath();

    /**
     * \brief Get sub-rectangle of the texture and return it as a new texture.
     *
     * \param x - X position
     * \param y - Y position
     * \param width - Width of the sub area.
     * \param height - Height of the sub area.
     *
     * \return ATexture - New texture.
     */
    virtual ATexture* GetSubTexture(int x, int y, int width, int height) = 0;

    /**
     * \brief Split this texture horizontaly into many smaller textures.
     *
     * The texture width will be divided by the number of splits and each
     * part will be returned as a separate texture.
     *
     * \param splits - How many splits to divide the width of the texture.
     *
     * \return ArrayList<ATexture> - List of new textures.
     */
    virtual ArrayList<ATexture*>* SplitTexture(int splits);

    /**
     * \brief Split this texture horizontaly and vertically by a number of rows
     * and columns.
     *
     * \param rows - Rows
     * \param columns - Columns
     *
     * \return ArrayList<ATexture> - List of new textures.
     */
    virtual ArrayList<ATexture*>* SplitTexture(int rows, int columns);

    /**
     * \brief Split this texture using a repeated rectangle to cut textures from
     * this texture.
     *
     * The cutting mechanism starts at the top left corner and copy the area of
     * the texture at that location. It will then move left and keep cutting
     * textures until it reaches the right edge. Then it will start at the
     * next row of the texture at the left edge. This will be repeated until
     * it reaches the lower right corner of the textures.
     *
     * Extra pixels read past the edges (in case the rectangle is not a perfect
     * divider of the image width/height) will be set to empty.
     *
     * \param pieceSize - Size of the cuts of each sub-texture.
     *
     * \return ArrayList<ATexture> - List of new textures.
     */
    virtual ArrayList<ATexture*>* SplitTexture(FRectangle pieceSize);

    /**
     * \brief Copy the pixels from another texture and apply it to this texture.
     *
     * \param other - Texture to read from.
     * \param sourcePos - Position to read from.
     * \param sourceSize - Size to read from.
     * \param destPos - Destination to copy the pixels on this texture.
     */
    virtual void CopyFrom(ATexture* other,
                          FPosition sourcePos,
                          FSize sourceSize,
                          FPosition destPos) = 0;

protected:
    ARenderer* BaseRenderer;
    const char* loadedTexturePath;

    FSize textureSize;
    bool isDirty;
};
